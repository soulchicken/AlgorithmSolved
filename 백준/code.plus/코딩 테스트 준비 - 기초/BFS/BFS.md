# BFS

1. [X] 1697_숨바꼭질
2. [X] 13913_숨바꼭질 4
3. [X] 14226_이모티콘
4. [X] 13549_숨바꼭질 3
5. [X] 알고스팟

## 문제 풀이 과정

1. 1697_숨바꼭질

    > - 입력 : 첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.
    > - 출력 : 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.
    > - 과정
    >   1. `[float('inf')]*(100001)`를 만든다. 이 리스트 각 인덱스에 도착하는 최소 시간을 표시한다.
    >   2. 큐에 `[0,N] # count,index를 의미` 를 추가하고, while문을 큐에 아무것도 남지 않을 때 까지 돌린다.
    >   3. 큐에서 popleft를 해서 해당 인덱스의 count가 리스트에 있는 값보다 작으면 리스트의 값을 count로 바꾼다.
    >   4. 그리고 1칸 앞으로, 1칸 뒤로, 2배 앞으로 이동을 큐에 추가한다.
    >   5. 리스트에서 인덱스 번호 K의 값을 출력한다.

2. 13913_숨바꼭질 4

    > - 입력 : 첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.
    > - 출력 : 첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.
    >   둘째 줄에 어떻게 이동해야 하는지 공백으로 구분해 출력한다.
    > - 과정
    >   1. `[float('inf')]*(100001)`를 만든다. 이 리스트 각 인덱스에 도착하는 최소 시간을 표시한다.
    >   2. `[0]*100001`리스트를 만든다. 이 리스트는 인덱스번호로 최소시간으로 갔을 때, 이전에 있었던 리스트 번호를 표시해준다.
    >   3. 큐에 `[0,0,N] # count,도착지, 출발지를 의미` 를 추가하고, while문을 큐에 아무것도 남지 않을 때 까지 돌린다.
    >   4. 큐에서 popleft를 해서 해당 인덱스의 count가 리스트에 있는 값보다 작으면 리스트의 값을 count로 바꾼다.
    >   5. 그리고 1칸 앞으로, 1칸 뒤로, 2배 앞으로 이동을 큐에 추가한다.
    >   6. 리스트에서 인덱스 번호 K의 값을 출력한다.
    >   7. 2.에서 만든 visit 리스트를 사용해 이동 경로를 추적하고 출력한다.

3. 14226_이모티콘

    > - 입력 : 첫째 줄에 S (2 ≤ S ≤ 1000) 가 주어진다.
    > - 출력 : 첫째 줄에 이모티콘을 S개 만들기 위해 필요한 시간의 최솟값을 출력한다.
    > - 과정
    >   1. `counts = [[50000]*2001 for _ in range(2001)]` 리스트를 만든다.
    >   2. `que.append((count, clip, index))` 큐에 추가하는 튜플이다.
    >   3. 클립보드에 새로 추가하기, 붙혀넣기, 화면에 하나 삭제를 while문을 통해 돌린다.
    >   4. counts 리스트에서 입력받은 수를 인덱스로 갖는 값을 출력한다.

4. 13549_숨바꼭질 3

    > - 입력 : 첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.
    > - 출력 : 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.
    > - 과정
    >   1. `[float('inf')]*(100001)`를 만든다. 이 리스트 각 인덱스에 도착하는 최소 시간을 표시한다.
    >   2. 큐에 `[0,N] # count,index를 의미` 를 추가하고, while문을 큐에 아무것도 남지 않을 때 까지 돌린다.
    >   3. 큐에서 popleft를 해서 해당 인덱스의 count가 리스트에 있는 값보다 작으면 리스트의 값을 count로 바꾼다.
    >   4. 그리고 1칸 앞으로(count += 1), 1칸 뒤로(count += 1), 2배 앞으로 이동을 큐에 추가한다.
    >   5. 리스트에서 인덱스 번호 K의 값을 출력한다.

5. 알고스팟

    > - 입력 : 첫째 줄에 미로의 크기를 나타내는 가로 크기 M, 세로 크기 N (1 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 미로의 상태를 나타내는 숫자 0과 1이 주어진다. 0은 빈 방을 의미하고, 1은 벽을 의미한다.
    >   (1, 1)과 (N, M)은 항상 뚫려있다.
    > - 출력 : 첫째 줄에 알고스팟 운영진이 (N, M)으로 이동하기 위해 벽을 최소 몇 개 부수어야 하는지 출력한다.
    > - 과정
    >   1. `counts = [[10000]*(M+2) for _ in range(N+2)]` 리스트를 만든다.
    >   2. (1,1)을 시작점으로 보고 값은 0을 넣는다 (N+1,M+1)까지 이중 for문을 M+N번 반복한다. (사실상 3중 for문)
    >   3. 3중 for에서는 i,j의 주변 4곳의 최솟값 + 0 or 1(방이 있으면 1, 없으면 0)을 더한 값과 해당 방의 카운트를 비교해 최솟값을 넣는다.
    >   4. 해당 방의 카운트값을 출력한다.