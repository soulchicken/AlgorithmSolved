# 브루트 포스 - 비트 마스크

1. [X] 1463_1로 만들기
2. [X] 11726_2xn 타일링
3. [X] 11727_2xn 타일링 2
4. [X] 9095_1, 2, 3 더하기
5. [ ] 11052_카드 구매하기
6. [ ] 16194_카드 구매하기 2
7. [X] 15990_1, 2, 3 더하기 5
8. [X] 10844_쉬운 계단 수
9. [X] 2193_이친수
10. [X] 11053_가장 긴 증가하는 부분 수열
11. [X] 14002_가장 긴 증가하는 부분 수열 4
12. [ ] 1912_연속합
13. [X] 1699_제곱수의 합
14. [ ] 14501_퇴사
15. [ ] 2225_합분해

## 문제 풀이 과정

1. 1463_1로 만들기

    > - 입력 : 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
    >   1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
    >   2. X가 2로 나누어 떨어지면, 2로 나눈다.
    >   3. 1을 뺀다.
    >   정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
    > - 출력 : 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.
    > - 과정
    >   1. n = 0,1 일 때 최솟값은 0, 0이다.
    >   2. n = k 일 때 최솟값은 n = ((k // 3 if k % 3 == 0) or (k // 2 if k % 2 == 0) or k - 1) 일 때 최솟값 + 1 이다.

2. 11726_2xn 타일링

    > - 입력 : 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)
    > - 출력 : 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.
    > - 과정
    >   1. n == 0 일 때, 경우의 수는 1개
    >   2. n == 1 일 때, 경우의 수는 1개
    >   3. n == 2 일 때, 경우의 수는 (n = 0 일 때) + (n = 1일 때)
    >   4. n == k 일 때, 경우의 수는 (n = k - 2 일 때) + (n = k - 1 일 때)

3. 11727_2xn 타일링 2

    > - 입력 : 첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)
    > - 출력 : 첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.
    > - 과정
    >   1. n == 0 일 때, 경우의 수는 1개
    >   2. n == 1 일 때, 경우의 수는 1개
    >   3. n == 2 일 때, 경우의 수는 (n = 0 일 때) * 2 + (n = 1일 때)
    >   4. n == k 일 때, 경우의 수는 (n = k - 2 일 때) * 2 + (n = k - 1 일 때)

4. 9095_1, 2, 3 더하기

    > - 입력 : 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.
    > - 출력 : 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.
    > - 과정
    >   1. n = 0,1,2 일 때의 경우의 수는 1,1,2이다.
    >   2. n = k일 때 경우의 수는 k-1,k-2,k-3일 때의 경우의 수의 합이다.

5. 카드 구매하기

    > - 입력 : d
    > - 출력 : d
    > - 과정
    >   1. d

6. 카드 구매하기 2

    > - 입력 : d
    > - 출력 : d
    > - 과정
    >   1. d

7. 15990_1, 2, 3 더하기 5

    > - 입력 : 정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다. 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.
    > - 출력 : 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.
    > - 과정
    >   1. n = 0일 때, 1,2,3으로 끝나는 수는 0,0,0개
    >   2. n = 1일 때, 1,2,3으로 끝나는 수는 1,0,0개
    >   3. n = 2일 때, 1,2,3으로 끝나는 수는 0,1,0개
    >   4. n = 3일 때, 1,2,3으로 끝나는 수는 1,1,1개
    >   5. n = k일 때, 1,2,3으로 끝나는 수는
    >       - 1로 끝나는 수 : k - 1일 때, 2,3으로 끝나는 수의 합
    >       - 2로 끝나는 수 : k - 2 일 때, 1,3으로 끝나는 수의 합
    >       - 3으로 끝나는 수 : k - 3 일 때, 1,2로 끝나는 수의 합

8. 10844_쉬운 계단 수

    > - 입력 : 첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.
    > - 출력 : 첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.
    > - 과정
    >   1. N * 10 크기의 2차원 배열을 만든다.
    >   2. i값은 N의 크기 (1,2,3 ... N), j값은 0부터 9를 나타낸다.
    >   3. N = 0 일 때, j = 1부터 9까지는 값을 1로 만들고 j = 0은 1로 만든다.
    >   4. N = 1 ~ N 까지는 `li[i-1][j+1]`과 `li[i-1][j+1]`의 값을 더한다. 그리고 1,000,000,000의 나머지로 만든다.
    >   5. `sum(li[N]) % 1000000000`을 출력한다.

9. 2193_이친수

    > - 입력 : 이친수는 0으로 시작하지 않는다 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다. 첫째 줄에 N이 주어진다.
    > - 출력 : 첫째 줄에 N자리 이친수의 개수를 출력한다.
    > - 과정
    >   1. n = 1 일 때, 0,1로 끝나는 수는 0,1개이다.
    >   2. n = 2 일 때, 0,1로 끝나는 수는 1,0개이다.
    >   3. n = 3 일 때, 0,1로 끝나는 수는 1,1개이다.
    >   4. n = k 일 때, 0,1로 끝나는 수는 (n = k-1 일 때 경우의 수),(n = k - 1일 때 0으로 끝나는 수)개이다.

10. 11053_가장긴 증가하는 부분 수열

    > - 입력 : 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
    > - 출력 : 첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.
    > - 과정
    >   1. 길이가 n인 count 리스트에 모두 1로 초기화한다.
    >   2. 이중 for문으로 해당 인덱스보다 작은 수가 있다면 count값을 비교해서 해당 인덱스의 count값을 변경한다.

11. 14002_가장 긴 증가하는 부분 수열 4

    > - 입력 : 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
    > - 출력 : 첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.
    >   둘째 줄에는 가장 긴 증가하는 부분 수열을 출력한다. 그러한 수열이 여러가지인 경우 아무거나 출력한다.
    > - 과정
    >   1. 길이가 n인 count 리스트에 모두 1로 초기화한다.
    >   2. 이중 for문으로 해당 인덱스보다 작은 수가 있다면 count값을 비교해서 해당 인덱스의 count값을 변경한다. 그리고 route에 직전에 있던 인덱스 번호를 추가한다.
    >   3. 가장 큰 값에서 route 리스트를 통해 경로를 추적하고 출력한다.

12. 연속합

    > - 입력 : d
    > - 출력 : d
    > - 과정
    >   1. d

13. 1699_제곱수의 합

    > - 입력 : 주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.
    > - 출력 : 주어진 자연수를 제곱수의 합으로 나타낼 때에 그 제곱수 항의 최소 개수를 출력한다.
    > - 과정
    >   1. 스택을 사용했다. (0,0)을 스택에 넣는다. (count,index) 형식으로 해당 인덱스에 몇 개의 수가 들어가는지 확인하게 된다.
    >   2. while문에서 스택을 팝하고, 0에 1부터 모든 제곱수를 더한 모든 경우를 스택에 쌓는다.
    >   3. while문에서는 팝, 모든 제곱수를 더하기를 계속 진행한다.
    >   4. 진행할 때마다 count를 업데이트한다.

14. 퇴사

    > - 입력 : d
    > - 출력 : d
    > - 과정
    >   1. d
