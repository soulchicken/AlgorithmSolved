# 다이나믹 프로래밍 Part 2

## CONTENTS

1. [15988_1, 2, 3 더하기 3](#1-159981-2-3-더하기-3)
2. 1149_RGB거리
3. 1309_동물원
4. 11057_오르막수
5. [2156_포도주 시식]
6. 1932_정수 삼각형
7. 11055_가장 큰 증가 부분 수열
8. [11722_가장 긴 감소하는 부분 수열](#8-11722가장-긴-감소하는-부분-수열)
9. 13398_연속합 2
10. 2133_타일 채우기

### 1. 15998_1, 2, 3 더하기 3

> - [코드](./15988_1%2C%202%2C%203%20%EB%8D%94%ED%95%98%EA%B8%B0%203.py) ⬅️ 클릭
> - 입력 : 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.
> - 출력 : 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.
> - 과정
>   1. n = 0 일 때 경우의 수는 1개
>   2. n = 1 일 때 경우의 수는 1개
>   3. n = 2 일 때 경우의 수는 2개
>   4. n = k 일 때 경우의 수는 (n = k - 1) + (n = k - 2) + (n = k - 3). (1, 2, 3이 작을 때의 경우의 수의 합)

### 5. 2156_포도주 시식

> - [코드](./2156_%ED%8F%AC%EB%8F%84%EC%A3%BC%20%EC%8B%9C%EC%8B%9D.py) ⬅️ 클릭
> - 입력 : 첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.
> - 출력 : 첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.
> - 과정
>   1. n = 0) 해당 인덱스를 안 고른 경우 0, 고른 경우 li[0]
>   2. n = 1) 안 고른 경우 중 가장 큰 수는 li[0], 고른 경우 연속으로 고른 경우는 li[0]+li[1], 연속은 아닌 경우 li[1]
>   3. n = k) 안 고른 경우 중 가장 큰 수는 그 전까지 가장 큰 수, 고른 경우는 안 고른 경우의 수 중 가장 큰 수,
>             2번 연속으로 고른 경우의 수는 n = k - 1에서 연속은 아닌 경우 + 해당 잔의 양

### 8. 11722_가장 긴 감소하는 부분 수열

> - [코드](./11722_가장%20긴%20감소하는%20부분%20수열.py) ⬅️ 클릭
> - 입력 : 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.
>   둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)
> - 출력 : 첫째 줄에 수열 A의 가장 긴 감소하는 부분 수열의 길이를 출력한다.
> - 과정
>   1. 길이가 n인 count 리스트에 모두 1로 초기화한다.
>   2. 입력된 리스트를 반대 순으로 만든다.
>   3. 이중 for문으로 해당 인덱스보다 작은 수가 있다면 count값을 비교해서 해당 인덱스의 count값을 변경한다.
