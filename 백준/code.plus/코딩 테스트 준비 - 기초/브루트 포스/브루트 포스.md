# 브루트 포스

1. [X] 2309_일곱 난쟁이
2. [X] 3085_사탕 게임
3. [X] 1476_날짜 계산
4. [X] 1107_리모컨
5. [X] 14500_테트로미노
6. [X] 6064_카잉 달력
7. [X] 1748_수 이어쓰기 1
8. [X] 9095_1,2,3 더하기

## 문제 풀이 과정

1. 2309_일곱 난쟁이

    > - 입력 : 아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.
    > - 출력 : 일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.
    > - 과정
    >    1. 9줄을 입력받고, 9명의 키 합을 구하고 100을 뺀다.
    >    2. 이중 for문을 통해 키의 합 - 100 이 되는 2명을 구한다.
    >    3. 그 둘을 제외하고, 출력한다.

2. 3085_사탕 게임

    > - 입력 : 첫째 줄에 보드의 크기 N이 주어진다. (3 ≤ N ≤ 50)
    >   다음 N개 줄에는 보드에 채워져 있는 사탕의 색상이 주어진다. 빨간색은 C, 파란색은 P, 초록색은 Z, 노란색은 Y로 주어진다.
    >   사탕의 색이 다른 인접한 두 칸이 존재하는 입력만 주어진다.
    > - 출력 : 첫째 줄에 상근이가 먹을 수 있는 사탕의 최대 개수를 출력한다.
    > - 과정
    >    1. 2차원 리스트로 사탕을 입력받는다.
    >    3. 이중 for문으로 좌우로, 위아래로 바뀌가면서 최대 개수를 구한다.


3. 1476_날짜 계산

    > - 입력 : 첫째 줄에 세 수 E, S, M이 주어진다. 문제에 나와있는 범위를 지키는 입력만 주어진다.
    > - 출력 : 준규가 사는 나라는 우리가 사용하는 연도와 다른 방식을 이용한다. 준규가 사는 나라에서는 수 3개를 이용해서 연도를 나타낸다. 각각의 수는 지구, 태양, 그리고 달을 나타낸다.
    >   지구를 나타내는 수를 E, 태양을 나타내는 수를 S, 달을 나타내는 수를 M이라고 했을 때, 이 세 수는 서로 다른 범위를 가진다. (1 ≤ E ≤ 15, 1 ≤ S ≤ 28, 1 ≤ M ≤ 19)
    >   우리가 알고있는 1년은 준규가 살고있는 나라에서는 1 1 1로 나타낼 수 있다. 1년이 지날 때마다, 세 수는 모두 1씩 증가한다. 만약, 어떤 수가 범위를 넘어가는 경우에는 1이 된다.
    >   예를 들어, 15년은 15 15 15로 나타낼 수 있다. 하지만, 1년이 지나서 16년이 되면 16 16 16이 아니라 1 16 16이 된다. 이유는 1 ≤ E ≤ 15 라서 범위를 넘어가기 때문이다.
    >   E, S, M이 주어졌고, 1년이 준규가 사는 나라에서 1 1 1일때, 준규가 사는 나라에서 E S M이 우리가 알고 있는 연도로 몇 년인지 구하는 프로그램을 작성하시오.
    > - 과정
    >    1. `e, s, m, count  = 0, 0, 0, 0 `에서 시작한다.
    >    2. `count`가 1 올라갈때마다, 나머지 `e, s, m`도 1씩 오른다.
    >    3. `e, s, m` 가 각각 16, 28, 19가 되면 1로 초기화한다.
    >    4. 입력에 주어진 `E, S, M`이 `e, s, m`과 같아지면 반복문을 종료한다.

4. 1107_리모컨

    > - 입력 : 첫째 줄에 수빈이가 이동하려고 하는 채널 N (0 ≤ N ≤ 500,000)이 주어진다.  둘째 줄에는 고장난 버튼의 개수 M (0 ≤ M ≤ 10)이 주어진다. 고장난 버튼이 있는 경우에는 셋째 줄에는 고장난 버튼이 주어지며, 같은 버튼이 여러 번 주어지는 경우는 없다.
    > - 출력 : 첫째 줄에 채널 N으로 이동하기 위해 버튼을 최소 몇 번 눌러야 하는지를 출력한다.
    > - 과정
    >   1. 원하는 채널과 현재 채널(!00)의 차이를 `count`에 남긴다.
    >   2. 0부터 9까지 있는 리스트에서 고장난 버튼을 `pop`한다.
    >   3. DFS로 깊이가 1부터 6일 때 모두 눌려진 채널과 원하는 채널의 차이를 `count`와 비교한다.

5. 14500_테트로미노

    > - 입력 : 첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)
    >   둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.
    > - 출력 : 첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.
    > - 과정
    >   1. 입력을 받아 2차원 리스트로 정리한다.
    >   2. DFS로 인접한 칸을 한 칸씩 먹어가면서 4칸이 채워지면 촤댓값과 비교한다.
    >   3. (추가) ㅗ, ㅜ, ㅏ, ㅓ 모양 형태를 구현하지 못해 따로 이중 for문을 돌렸다.

6. 6064_카잉 달력

    > - 입력 : 입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터는 한 줄로 구성된다. 각 줄에는 네 개의 정수 M, N, x와 y가 주어진다. (1 ≤ M, N ≤ 40,000, 1 ≤ x ≤ M, 1 ≤ y ≤ N) 여기서 <M:N>은 카잉 달력의 마지막 해를 나타낸다.
    > - 출력 : 출력은 표준 출력을 사용한다. 각 테스트 데이터에 대해, 정수 k를 한 줄에 출력한다. 여기서 k는 <x:y>가 k번째 해를 나타내는 것을 의미한다. 만일 <x:y>에 의해 표현되는 해가 없다면, 즉, <x:y>가 유효하지 않은 표현이면, -1을 출력한다.
    > - 과정
    >   1. 입력을 받는다. 그리고 `a, b, count = 0, 0, 0` 상태로 한다. a,b는 각각 x,y 를 나타낸다.
    >   2. `a`를 일단 `M`에 맞춘다. (그 것에 맞춰 `b`의 수가 바뀐다.)
    >   3. 해를 `M`씩 더하는 반복문을 `N` 번 반복하면서 `b == N`이 되는지 확인한다.
    >   4. 반복문이 도 중 완성되면 횟수 출력
    >   5. 다 돌 때까지 되지 않으면 `-1` 출력

7. 1748_수 이어쓰기 1

    > - 입력 : 첫째 줄에 N(1 ≤ N ≤ 100,000,000)이 주어진다.
    > - 출력 : 1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다.
    >   1234567891011121314151617181920212223...
    >    이렇게 만들어진 새로운 수는 몇 자리 수일까? 이 수의 자릿수를 구하는 프로그램을 작성하시오.
    > - 과정
    >    1. 1부터 9까지 개수 구하기
    >    2. 10부터 99까지 개수 구하기
    >    3. 100부터 999까지 개수 구하기
    >    4. 1000부터 9999까지 개수 구하기
    >    5. 10000부터 99999까지 개수 구하기
    >    6. ... 끝까지 한다.
    >    7. 전체 개수를 출력한다.

8. 9095_1,2,3 더하기

    > - 입력 : 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.
    > - 출력 : 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.
    > - 과정
    >    1. 11보다 작은 양수이므로 0부터 10까지 모든 수의 경우의 수를 구하여 리스트화한다.
    >    2. 0, 1, 2는 경우의 수가 1개 1개 2개이다.
    >    3. 3은 0에서 3을 더하기, 1에서 2를 더하기, 2에서 1을 더하기이다.
    >    4. 4는 1에서 3을 더하기, 2에서 2를 더하기, 3에서 1을 더하기이다.
    >    5. 3,4의 논리로 10까지 구한다.
    >    6. 테스트 케이스에 맞는 경우의 수를 출력한다.