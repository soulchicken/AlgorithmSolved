# 수학
1. [X] 10430_나머지
1. [X] 4375_1
1. [X] 1037_약수
1. [X] 17427_약수의 합 2
1. [X] 17425_약수의 합
1. [X] 2609_최대공약수와 최소공배수
1. [ ] 1978_소수 찾기
1. [ ] 1929_소수 구하기
1. [ ] 6588_골드바흐의 추측

## 문제 풀이 과정
1. 10430_나머지
    > - 입력 : 첫째 줄에 A, B, C가 순서대로 주어진다. (2 ≤ A, B, C ≤ 10000)
    > - 첫째 줄에 (A+B)%C, 둘째 줄에 ((A%C) + (B%C))%C, 셋째 줄에 (A×B)%C, 넷째 줄에 ((A%C) × (B%C))%C를 출력한다.
    > - 과정
    >    1. 입력값을 split으로 나누고 int값으로 mapping한 후 각 식에 대입하여 출력한다.
    
1. 4375_1
    > - 입력 : 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, n이 주어진다.
    > - 1로 이루어진 n의 배수 중 가장 작은 수의 자리수를 출력한다.
    > - 과정
    >   1. 여러 줄 입력받지만 몇 줄을 받을 지 모르기 때문에 while문 안에 try, except를 사용한다
    >   2. 1로 이뤄진 수 : 1, 11, 111, 1111 ...
    >   3. while문으로 1로 이뤄진 수를 하나씩 입력받은 숫자로 나눈다.
    >   4. 나눠떨어지면 1로 이뤄진 수의 자릿수 출력
1. 1037_약수
    >- 입력 : 첫째 줄에 N의 진짜 약수의 개수가 주어진다. 이 개수는 50보다 작거나 같은 자연수이다. 둘째 줄에는 N의 진짜 약수가 주어진다. 1,000,000보다 작거나 같고, 2보다 크거나 같은 자연수이고, 중복되지 않는다.
    > - 양수 A가 N의 진짜 약수가 되려면, N이 A의 배수이고, A가 1과 N이 아니어야 한다. 어떤 수 N의 진짜 약수가 모두 주어질 때, N을 구하는 프로그램을 작성하시오.
    > - 과정
    >   1. 입력받은 약수들의 최대, 최소값을 곱하면 원하는 답이 나온다
    >   2. 만약 약수가 1개라면, 그 수의 제곱이다. 최대, 최소값은 그 한 개의 수 밖에 없다.

2. 17427_약수의 합 2
    >- 입력 : 첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
    > - 두 자연수 A와 B가 있을 때, A = BC를 만족하는 자연수 C를 A의 약수라고 한다. 예를 들어, 2의 약수는 1, 2가 있고, 24의 약수는 1, 2, 3, 4, 6, 8, 12, 24가 있다. 자연수 A의 약수의 합은 A의 모든 약수를 더한 값이고, f(A)로 표현한다. x보다 작거나 같은 모든 자연수 y의 f(y)값을 더한 값은 g(x)로 표현한다.
    > 자연수 N이 주어졌을 때, g(N)을 구해보자.
    > - 과정
    >   1. 1은 1부터 n까지 수의 약수이다. -> n * 1
    >   2. 2는 2부터 n//2개 존재한다. -> 2 * (n // 2)
    >   3. 3은 3부터 n//3개 존재한다. -> 3 * (n // 3)
    >   4. n은 n부터 n//n개 (1개) 존재한다. -> n * (n // n)
    >   5. 1부터 n까지 k * (n // k) 를 더한다.
3. 17425_약수의 합
    >- 입력 : 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 100,000)가 주어진다. 둘째 줄부터 테스트 케이스가 한 줄에 하나씩 주어지며 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
    > - 두 자연수 A와 B가 있을 때, A = BC를 만족하는 자연수 C를 A의 약수라고 한다. 예를 들어, 2의 약수는 1, 2가 있고, 24의 약수는 1, 2, 3, 4, 6, 8, 12, 24가 있다. 자연수 A의 약수의 합은 A의 모든 약수를 더한 값이고, f(A)로 표현한다. x보다 작거나 같은 모든 자연수 y의 f(y)값을 더한 값은 g(x)로 표현한다.
    > 자연수 N이 주어졌을 때, g(N)을 구해보자.
    > - 과정 (17427_약수의 합 2처럼 풀면 시간초과가 나온다.)
    >   1. 0부터 100만 까지 인덱스를 가진 리스트(li) 생성 (모든 값은 0)
    >   2. 1부터 100만 까지 수 i를 하나씩 꺼내 1부터 100만까지의 수 중 약수가 되는 수에 i를 더한다. 
    >   3. 0부터 100만까지 값이 0인 리스트(total)를 하나 더 만들고 li를 사용해 각 total값을 구한다. (total[i] = total[i-1] + li[i])
    >   4. 필요한 인덱스 번호를 출력

4. 2609_최대공약수와 최소공배수
    >- 입력 : 첫째 줄에는 두 개의 자연수가 주어진다. 이 둘은 10,000이하의 자연수이며 사이에 한 칸의 공백이 주어진다.
    >- 출력 : 첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.
    >- 과정 : 유클리드 호제법을 사용하여 최대 공약수를 구하고, 두 수를 곱한 값에서 최대 공약수를 나눠서 최소 공배수를 구한다.


5. 1978_소수 찾기
6. 1929_소수 구하기
7. 6588_골드바흐의 추측