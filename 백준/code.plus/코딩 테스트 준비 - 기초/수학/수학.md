# 수학
1. [X] 10430_나머지
1. [X] 4375_1
1. [X] 1037_약수
1. [X] 17427_약수의 합 2
1. [X] 17425_약수의 합
1. [X] 2609_최대공약수와 최소공배수
1. [X] 1978_소수 찾기
1. [X] 1929_소수 구하기
1. [X] 6588_골드바흐의 추측

## 문제 풀이 과정
1. 10430_나머지
    > - 입력 : 첫째 줄에 A, B, C가 순서대로 주어진다. (2 ≤ A, B, C ≤ 10000)
    > - 첫째 줄에 (A+B)%C, 둘째 줄에 ((A%C) + (B%C))%C, 셋째 줄에 (A×B)%C, 넷째 줄에 ((A%C) × (B%C))%C를 출력한다.
    > - 과정
    >    1. 입력값을 split으로 나누고 int값으로 mapping한 후 각 식에 대입하여 출력한다.
    
1. 4375_1
    > - 입력 : 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, n이 주어진다.
    > - 1로 이루어진 n의 배수 중 가장 작은 수의 자리수를 출력한다.
    > - 과정
    >   1. 여러 줄 입력받지만 몇 줄을 받을 지 모르기 때문에 while문 안에 try, except를 사용한다
    >   2. 1로 이뤄진 수 : 1, 11, 111, 1111 ...
    >   3. while문으로 1로 이뤄진 수를 하나씩 입력받은 숫자로 나눈다.
    >   4. 나눠떨어지면 1로 이뤄진 수의 자릿수 출력
1. 1037_약수
    >- 입력 : 첫째 줄에 N의 진짜 약수의 개수가 주어진다. 이 개수는 50보다 작거나 같은 자연수이다. 둘째 줄에는 N의 진짜 약수가 주어진다. 1,000,000보다 작거나 같고, 2보다 크거나 같은 자연수이고, 중복되지 않는다.
    > - 양수 A가 N의 진짜 약수가 되려면, N이 A의 배수이고, A가 1과 N이 아니어야 한다. 어떤 수 N의 진짜 약수가 모두 주어질 때, N을 구하는 프로그램을 작성하시오.
    > - 과정
    >   1. 입력받은 약수들의 최대, 최소값을 곱하면 원하는 답이 나온다
    >   2. 만약 약수가 1개라면, 그 수의 제곱이다. 최대, 최소값은 그 한 개의 수 밖에 없다.

2. 17427_약수의 합 2
    >- 입력 : 첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
    > - 두 자연수 A와 B가 있을 때, A = BC를 만족하는 자연수 C를 A의 약수라고 한다. 예를 들어, 2의 약수는 1, 2가 있고, 24의 약수는 1, 2, 3, 4, 6, 8, 12, 24가 있다. 자연수 A의 약수의 합은 A의 모든 약수를 더한 값이고, f(A)로 표현한다. x보다 작거나 같은 모든 자연수 y의 f(y)값을 더한 값은 g(x)로 표현한다.
    > 자연수 N이 주어졌을 때, g(N)을 구해보자.
    > - 과정
    >   1. 1은 1부터 n까지 수의 약수이다. -> n * 1
    >   2. 2는 2부터 n//2개 존재한다. -> 2 * (n // 2)
    >   3. 3은 3부터 n//3개 존재한다. -> 3 * (n // 3)
    >   4. n은 n부터 n//n개 (1개) 존재한다. -> n * (n // n)
    >   5. 1부터 n까지 k * (n // k) 를 더한다.
3. 17425_약수의 합
    >- 입력 : 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 100,000)가 주어진다. 둘째 줄부터 테스트 케이스가 한 줄에 하나씩 주어지며 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
    > - 두 자연수 A와 B가 있을 때, A = BC를 만족하는 자연수 C를 A의 약수라고 한다. 예를 들어, 2의 약수는 1, 2가 있고, 24의 약수는 1, 2, 3, 4, 6, 8, 12, 24가 있다. 자연수 A의 약수의 합은 A의 모든 약수를 더한 값이고, f(A)로 표현한다. x보다 작거나 같은 모든 자연수 y의 f(y)값을 더한 값은 g(x)로 표현한다.
    > 자연수 N이 주어졌을 때, g(N)을 구해보자.
    > - 과정 (17427_약수의 합 2처럼 풀면 시간초과가 나온다.)
    >   1. 0부터 100만 까지 인덱스를 가진 리스트(li) 생성 (모든 값은 0)
    >   2. 1부터 100만 까지 수 i를 하나씩 꺼내 1부터 100만까지의 수 중 약수가 되는 수에 i를 더한다. 
    >   3. 0부터 100만까지 값이 0인 리스트(total)를 하나 더 만들고 li를 사용해 각 total값을 구한다. (total[i] = total[i-1] + li[i])
    >   4. 필요한 인덱스 번호를 출력

4. 2609_최대공약수와 최소공배수
    >- 입력 : 첫째 줄에는 두 개의 자연수가 주어진다. 이 둘은 10,000이하의 자연수이며 사이에 한 칸의 공백이 주어진다.
    >- 출력 : 첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.
    >- 과정 : 유클리드 호제법을 사용하여 최대 공약수를 구하고, 두 수를 곱한 값에서 최대 공약수를 나눠서 최소 공배수를 구한다.

5. 1978_소수 찾기
    >- 입력 : 첫 줄에 수의 개수 N이 주어진다. N은 100이하이다. 다음으로 N개의 수가 주어지는데 수는 1,000 이하의 자연수이다.
    >- 출력 : 주어진 수들 중 소수의 개수를 출력한다.
    >- 과정 : 아리스토테네스의 체를 사용해 1000 이하의 소수를 먼저 리스트업 한 후 입력받은 수 중 소수가 리스트에 있는지 확인한다.

6. 1929_소수 구하기
    >- 입력 : 첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.
    >- 출력 : M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.
    >- 과정 : 아리스토테네스의 체를 사용해 100000 이하의 소수를 먼저 리스트업 한 후 입력받은 두 수 사이에 소수가 있다면 출력
7.  6588_골드바흐의 추측
    >- 입력 : 입력은 하나 또는 그 이상의 테스트 케이스로 이루어져 있다. 테스트 케이스의 개수는 100,000개를 넘지 않는다.
    >   각 테스트 케이스는 짝수 정수 n 하나로 이루어져 있다. (6 ≤ n ≤ 1000000)
    >   입력의 마지막 줄에는 0이 하나 주어진다.
    >- 출력 : 각 테스트 케이스에 대해서, n = a + b 형태로 출력한다. 이때, a와 b는 홀수 소수이다. 숫자와 연산자는 공백 하나로 구분되어져 있다. 만약, n을 만들 수 있는 방법이 여러 가지라면, b-a가 가장 큰 것을 출력한다. 또, 두 홀수 소수의 합으로 n을 나타낼 수 없는 경우에는 "Goldbach's conjecture is wrong."을 출력한다.
    >- 과정
    >   1. 아리스토테네스의 체를 사용해 100000 이하의 소수를 먼저 리스트업 한다.
    >   2. while문으로 입력이 0이 될 때까지 입력받는다.
    >   3. for 문을 사용해 리스트업한 소수 2개를 골라 합이 나오는지 확인하고 출력한다.